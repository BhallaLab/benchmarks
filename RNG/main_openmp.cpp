/***
 *       Filename:  main.cpp
 *
 *    Description:  Benchmark three random number generators with OpenMPI.
 *
 *        Version:  0.0.1
 *        Created:  2016-04-02

 *       Revision:  none
 *
 *         Author:  Dilawar Singh <dilawars@ncbs.res.in>
 *   Organization:  NCBS Bangalore
 *
 *        License:  GNU GPL2
 */

#include <iostream>
#include <ctime>
#include <chrono>
#include <random>
#include <cmath>
#include <vector>
#include <gsl/gsl_rng.h>
#include <omp.h>
#include <tuple>
#include <algorithm>

using namespace std;
using namespace std::chrono;

double d_t (struct timespec t1, struct timespec t2)
{
    return (t2.tv_sec-t1.tv_sec)+(double)(t2.tv_nsec-t1.tv_nsec)/1000000.0;
}

tuple<double, double> mean_and_std( vector<double>& v )
{
    double sum = std::accumulate(v.begin(), v.end(), 0.0);
    double mean = sum / v.size();

    double sq_sum = std::inner_product(v.begin(), v.end(), v.begin(), 0.0);
    double stdev = std::sqrt(sq_sum / v.size() - mean * mean);
    return make_tuple(mean, stdev);
}

template<typename T>
void generate_rand_vec( T rng, vector<long>& res, double& time )
{
    struct timespec t1, t2;
    clock_gettime( CLOCK_PROCESS_CPUTIME_ID, &t1);
    for (size_t i = 0; i < res.size(); i++) {
        //res[i] = gsl_rng_get( rng );
#if USE_GSL
        gsl_rng_get( rng );
#else
        rng();
#endif
    }
    clock_gettime( CLOCK_PROCESS_CPUTIME_ID, &t2);
    time =(t2.tv_sec-t1.tv_sec)+(double)(t2.tv_nsec-t1.tv_nsec)/1000000.0;
    // printf("| Time taken to generate %lu numbers = %f ms\n", res.size(), time);
}

int main(int argc, char *argv[])
{
    unsigned int i, j;                          /* Used in loop, if ever */
    unsigned int seed = 2;                      /* Seed for RNG. */
    unsigned int nt = 2;                        /* No of threads to launch */

    long a;                                     /* Number generated by RNG. */
    size_t N = pow(10, 8);                      /* Numbers to be generated. */
    struct timespec t1, t2, t3, t4;

    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &t1);

#ifdef USE_GSL
    //initialize gsl random number generator
    const gsl_rng_type *rng_t;
    gsl_rng **rng;
    gsl_rng_env_setup();
    rng_t = gsl_rng_default;                    /* mersenne twister 19377mt */
    rng = (gsl_rng **) malloc(nt * sizeof(gsl_rng *));
#else
    vector<mt19937> rng(nt);
#endif 


    /*-----------------------------------------------------------------------------
     *  I wish to create N standalone RNG instances. This directive does that.
     *-----------------------------------------------------------------------------*/
#pragma omp parallel for num_threads(nt)
    for (i = 0; i < nt; i++) {
#ifdef USE_GSL
        rng[i] = gsl_rng_alloc (rng_t);
        gsl_rng_set(rng[i],seed*i);
#else 
        mt19937 r(seed*i);
        rng[i] = r;
        printf("Craeted RNG : %p\n", rng[i] );
#endif
    }

    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &t2);
    printf("Time taken to create RNGS %f ms.\n", d_t( t1, t2) );

    /*-------------------------------------------------------------------------
     * Let's generate a sequence of numbers from one of the rngs created  to
     * check if rng is working properly.
     *----------------------------------------------------------------------- */
    unsigned int nn = 10;
    printf("[CHECK] %d number from seq of two distinct RNGs\n", nn);
    for (i = 0; i < nn; i++)  {
#if USE_GSL
        printf(" %lu,", gsl_rng_get(rng[0]) );
#else
        printf(" %lu,", rng[0]() );
#endif
    }
    printf("\n");
    for (i = 0; i < nn; i++) { 
#if USE_GSL
        printf(" %lu,", gsl_rng_get(rng[1]) );
#else
        printf(" %lu,", rng[1]() );
#endif

    }
    printf("\n");

    /*-----------------------------------------------------------------------------
     *  Now we do the benchmarking.
     *  First we generate N numbers using a rng in sequentially and put it into
     *  a container.
     -------------------------------------------------------------*/
    nn = 20;
    vector<long> result(N);
    vector<double> timeVec(nn);
    double timeTaken = 0.0;
    printf("[INFO] Generating %d numbers in serial, %d times", N, nn);
    for (i = 0; i < nn; i++) {
#if USE_GSL
        generate_rand_vec<gsl_rng_type*>( rng[0], result, timeTaken);
#else
        generate_rand_vec<mt19937>( rng[0], result, timeTaken);
#endif
        timeVec.push_back( timeTaken );
    }
    auto res = mean_and_std( timeVec );
    printf("\n\tDone. Mean = %f, std = %f\n", get<0>(res), get<1>(res));

    omp_set_num_threads(nt);

    vector<double> parallelTime(nt);
    printf("[INFO] Generating %d numbers in %d threads\n", N, nt);

    // NOTE: Not sure if pushing into parallelTime is a good idea.
    int tid;
#pragma omp parallel private(tid) num_threads( nt ) shared( parallelTime )
    {
        tid = omp_get_thread_num();
#if USE_GSL
        generate_rand_vec<gsl_rng_type*>( rng[tid], result, timeTaken);
#else
        generate_rand_vec<mt19937>( rng[tid], result, timeTaken);
#endif
        printf("%d thread, Time taken %f\n", tid, timeTaken);
        parallelTime[tid] = timeTaken;
    }

    res = mean_and_std( parallelTime );
    printf("\n\tDone. Mean = %f, std = %f\n", get<0>(res), get<1>(res));

    //free random number generator
#if USE_GSL
    for (i = 0; i < nt; i++) {
        gsl_rng_free(rng[i]);
    }
    free(rng);
#endif

    return 0;

}

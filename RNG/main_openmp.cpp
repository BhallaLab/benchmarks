/***
 *       Filename:  main.cpp
 *
 *    Description:  Benchmark three random number generators with OpenMPI.
 *
 *        Version:  0.0.1
 *        Created:  2016-04-02

 *       Revision:  none
 *
 *         Author:  Dilawar Singh <dilawars@ncbs.res.in>
 *   Organization:  NCBS Bangalore
 *
 *        License:  GNU GPL2
 */

#include <iostream>
#include <ctime>
#include <typeinfo>
#include <chrono>
#include <random>
#include <cmath>
#include <vector>
#include <gsl/gsl_rng.h>
#include <omp.h>
#include <tuple>
#include <algorithm>
#include <chrono>

#define NUMBERS_TO_GENERATE     pow(10,8)       /* How many numbers to generate. */

using namespace std;
using namespace std::chrono;

double d_t (struct timespec t1, struct timespec t2)
{
    return (t2.tv_sec-t1.tv_sec)+(double)(t2.tv_nsec-t1.tv_nsec)/1000000.0;
}

tuple<double, double> mean_and_std( vector<double>& v )
{
    double sum = std::accumulate(v.begin(), v.end(), 0.0);
    double mean = sum / v.size();

    double sq_sum = std::inner_product(v.begin(), v.end(), v.begin(), 0.0);
    double stdev = std::sqrt(sq_sum / v.size() - mean * mean);
    return make_tuple(mean, stdev);
}

template<typename T>
void generate_random_nums( T rng, long& sum, double& time )
{
    struct timespec t1, t2;
    double start = omp_get_wtime();
    for (size_t i = 0; i < NUMBERS_TO_GENERATE; i++) {
#if USE_GSL
        sum += gsl_rng_get( rng );
#else
        rng();                                  /* Just generate, do nothing */
#endif
    }
    time = (omp_get_wtime() - start) * 1000;
}


int main(int argc, char *argv[])
{
    unsigned int seed = 2;                      /* Seed for RNG. */
    unsigned int numThreads = 1;               /* No of threads to launch */

    long a;                                     /* Number generated by RNG. */
    size_t N = pow(10, 7);                      /* Numbers to be generated. */
    struct timespec t1, t2, t3, t4;

    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &t1);

#ifdef USE_GSL
    //initialize gsl random number generator
    const gsl_rng_type *rng_t;
    rng_t = gsl_rng_default;                    /* mersenne twister 19377mt */
    gsl_rng_env_setup();
    vector<gsl_rng*> rngVec;
#else
    vector<mt19937> rngVec(numThreads);
#endif 

    for (int i = 0; i < numThreads; i++) {
#ifdef USE_GSL
        rngVec[i] = gsl_rng_alloc (rng_t);
        gsl_rng_set(rngVec[i], seed*i);
        printf("[INFO] Created gsl RNG : %p, seed = %d\n"
                , rngVec[i], gsl_rng_get(rngVec[i]) 
              );
#else 
        std::mt19937 r;
        r.seed(seed*i);
        rngVec[i] = r;
//        printf("[INFO] Created stl RNG : %p, seed = %d\n" , &rngVec[i], seed*i );
#endif
    }

    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &t2);
    printf("[INFO] Time taken to create RNGS %f ms.\n", d_t( t1, t2) );

    /*-------------------------------------------------------------------------
     * Let's generate a sequence of numbers from one of the rngs created  to
     * check if rngVec is working properly.
     *----------------------------------------------------------------------- */
    unsigned int nn = 10;
    printf("[CHECK] %d number from seq of two distinct RNGs\n", nn);
    for (int i = 0; i < nn; i++)  {
#if USE_GSL
        printf(" %lu,", gsl_rng_get(rngVec[0]) );
#else
        printf(" %lu,", rngVec[0]() );
#endif
    }
    printf("\n");
    for (int i = 0; i < nn; i++) { 
#if USE_GSL
        printf(" %lu,", gsl_rng_get(rngVec[1]) );
#else
        printf(" %lu,", rngVec[1]() );
#endif

    }
    printf("\n");

    /*-----------------------------------------------------------------------------
     *  Now we do the benchmarking.
     *  First we generate N numbers using a rngVec in sequentially and put it into
     *  a container.
     -------------------------------------------------------------*/
    nn = 20;
    long sum = 0;
    vector<double> timeVec(nn);
    double timeTaken = 0.0;
    printf("[INFO] Generating %lu numbers in serial, %d times", N, nn);

    for (int i = 0; i < nn; i++) {
#if USE_GSL
        generate_random_nums<gsl_rng_type*>( rngVec[0], sum, timeTaken);
#else
        generate_random_nums<mt19937>( rngVec[0], sum, timeTaken);
#endif
        timeVec.push_back( timeTaken );
    }
    auto serialRes = mean_and_std( timeVec );
    printf("\n\tDone. Mean = %f, std = %f\n", get<0>(serialRes), get<1>(serialRes));

    omp_set_num_threads(numThreads);

    vector<double> parallelTime(numThreads);
    printf("[INFO] Generating %d numbers in %d threads\n", N, numThreads);

    // NOTE: Not sure if pushing into parallelTime is a good idea.
    int tid;
#pragma omp parallel private(tid) shared( parallelTime )
    {
        double threadTime = 0;
        tid = omp_get_thread_num();
#if USE_GSL
        generate_random_nums<gsl_rng_type*>( rngVec[tid], sum, threadTime);
#else
        generate_random_nums<mt19937>( rngVec[tid], sum, threadTime);
#endif
//        printf( "\t%d thread, Time taken %f\n", tid, threadTime);
        parallelTime[tid] = threadTime;
    }

    auto paralleRes = mean_and_std( parallelTime );
    printf("\nTime taken in parallel version\n\t. Mean = %f, std = %f\n"
            , get<0>(paralleRes), get<1>(paralleRes)
          );

    //free random number generator
#if USE_GSL
    for (i = 0; i < numThreads; i++) {
        gsl_rng_free(rngVec[i]);
    }
    free(rngVec);
#endif

    return 0;
}

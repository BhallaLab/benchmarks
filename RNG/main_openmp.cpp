/***
 *       Filename:  main.cpp
 *
 *    Description:  Benchmark three random number generators with OpenMPI.
 *
 *        Version:  0.0.1
 *        Created:  2016-04-02

 *       Revision:  none
 *
 *         Author:  Dilawar Singh <dilawars@ncbs.res.in>
 *   Organization:  NCBS Bangalore
 *
 *        License:  GNU GPL2
 */

#include <iostream>
#include <ctime>
#include <chrono>
#include <cmath>
#include <vector>
#include <gsl/gsl_rng.h>
#include <omp.h>

using namespace std;
using namespace std::chrono;

double d_t (struct timespec t1, struct timespec t2)
{
    return (t2.tv_sec-t1.tv_sec)+(double)(t2.tv_nsec-t1.tv_nsec)/1000000.0;
}

void generate_rand_vec( const gsl_rng* rng, vector<long>& res )
{
    struct timespec t1, t2;
    clock_gettime( CLOCK_PROCESS_CPUTIME_ID, &t1);
    for (size_t i = 0; i < res.size(); i++) {
        //res[i] = gsl_rng_get( rng );
        gsl_rng_get( rng );
    }
    clock_gettime( CLOCK_PROCESS_CPUTIME_ID, &t2);
    printf("| Time taken to generate %lu numbers = %f ms\n",
             res.size(), d_t(t1, t2)
          );
}

int main(int argc, char *argv[])
{
    unsigned int i, j;                          /* Used in loop, if ever */
    unsigned int seed = 2;                      /* Seed for RNG. */
    unsigned int nt = 9;                        /* No of threads to launch */

    long a;                            /* Number generated by RNG. */
    size_t N = 100000;                          /* Numbers to be generated. */
    struct timespec t1, t2, t3, t4;

    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &t1);

    //initialize gsl random number generator
    const gsl_rng_type *rng_t;
    gsl_rng **rng;
    gsl_rng_env_setup();
    rng_t = gsl_rng_default;                    /* mersenne twister 19377mt */

    rng = (gsl_rng **) malloc(nt * sizeof(gsl_rng *));

    /*-----------------------------------------------------------------------------
     *  I wish to create N standalone RNG instances. This directive does that.
     *-----------------------------------------------------------------------------*/
#pragma omp parallel for num_threads(nt)
    for (i = 0; i < nt; i++) {
        rng[i] = gsl_rng_alloc (rng_t);
        gsl_rng_set(rng[i],seed*i);
        printf("Craeted RNG : %p\n", rng[i] );
    }

    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &t2);
    printf("Time taken to create RNGS %f ms.\n", d_t( t1, t2) );

    /*-------------------------------------------------------------------------
     * Let's generate a sequence of numbers from one of the rngs created  to
     * check if rng is working properly.
     *----------------------------------------------------------------------- */
    for (i = 0; i < nt; i++) {
        a = gsl_rng_get(rng[0]);
        printf("  %d rand num =  %d  \n", i, a );
    }

    /*-----------------------------------------------------------------------------
     *  Now we do the benchmarking.
     *  First we generate N numbers using a rng in sequentially and put it into
     *  a container.
     *-----------------------------------------------------------------------------*/
    vector<long> result(N);
    generate_rand_vec( rng[0], result);

    omp_set_num_threads(nt);

#pragma omp parallel for num_threads(nt)
    for (i = 0; i < nt; i++) {
        j = omp_get_thread_num();
        generate_rand_vec( rng[j], result);
    }

    //free random number generator
    for (i = 0; i < nt; i++) {
        gsl_rng_free(rng[i]);
    }

    free(rng);
    return 0;

}
